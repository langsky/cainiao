# JavaScript 语言核心

## 词法结构

### 字符集

1. JavaScript使用Unicode字符集书写。
2. JavaScript区分大小写，但是和HTML交互时，传入变量一律使用小写。
3. JavaScript将部分格式控制符理解为一个空格，部分格式控制符理解为行结束符。
4. JavaScript支持Unicode的转义序列。

### 注释

1. JavaScript和Java的注释类似。

### 直接量

1. 直接量，就是在程序中直接使用的值。

### 标识符

1. 标识符以`$ _ `和字母开头。
2. 字母不仅仅指英文字母，还可以是数学符号（一般是常量符号），其他语言字母，甚至是中文。

### 保留字

1. 保留字不允许作为标识符。
2. JavaScript定义了许多全局变量，不要使用全局变量作为标识符。

### 分号

1. 分号不是必须的。
2. 分号只有在解析出现语义歧义时才派上用场。
3. JavaScript自行添加的断句往往和期望结果不一致，所以不要偷懒，还是使用分号吧。

## 类型 值 变量

1. JavaScript的数据类型分为两类，分别是原始类型和对象类型。原始类型中有一种null和undefind的特殊类型，对象类型中有一种特殊的形式，称为全局对象。
2. 普通对象类型是键值的无序集合，JavaScript还提供了一种有序集合对象，称为数组。
3. 函数是一种特殊的对象类型。

### 数字

1. JavaScript不区分整数值和浮点值。
2. JavaScript整数值范围[$-2^53$,$2^53$]
3. JavaScript实际的操作基于32位整数。
4. 数字是直接量。
5. 整形数字可以使用八进制，十进制和十六进制表示。
6. 浮点数字可以使用科学计数法表示。
7. 数字支持加减乘除余计算，同时对象`Math`支持更复杂的计算。
8. JavaScript数字会溢出。分为无穷大`Infinity`和趋于0（正负0）的情况。
9. JavaScript除数为0不会报错，但是会发生错误，返回`NaN`。
10. `NaN`十分特殊，它和任何值都不相等，包括它自己，所以判断方式是`i!=i`，为真就是`NaN`。
11. 正0和负0相等，但它们作为除数时的计算结果不相等。
12. JavaScript无法准确表示十进制的小数。
13. `Date`类型提供时间的计算方法。

### 文本

1. JavaScript字符串以UTF-16编码格式的Unicode码。
2. JavaScript定义的字符串操作方法均作用于16位值。（这个要研究一下）
3. 字符串自带计算方法，用来返回处理后的结果。注意，字符串本身不会改变。
4. JavaScript支持使用正则表达式匹配字符串。

### 布尔值

1. 布尔值只有两个，true和false。
2. undefined，null，0，-0，NaN，""都是false。

### null undefined

1. null是对象，含义是“非对象”。表示数字无值。
2. undefined表示对象不存在，即未初始化或未声明。
3. 它们没有成员方法，不要尝试去取它们的属性。
4. null==undefined, null!==undefined

### 全局对象

1. 全局对象在解释器启动时创建。
2. 全局对象包含全局属性，全局函数，构造函数，全局对象。
3. 全局属性，比如NaN，undefined，Infinity等。
4. 全局函数，比如`isNaN()`，`parseInt()`等。
5. 构造函数，比如`Date()`，`RegExp()`等。
6. 全局对象，比如Math，JSON等。
7. 获取全局变量的一个引用，在文件头部声明一个变量`var global = this`即可。

### 包装对象

1. 很奇怪原始类型比如数字，布尔，字符串为什么会有属性呢？
2. 这是因为在你试图访问属性时，JavaScript为这些原始类型临时创建了一个对象。
3. 这个过程叫做包装对象。
4. 包装产生的对象不会长时间存在，所以不要给它们指定新的属性，因为那是不成功的。
5. 或者说，原始对象都是只读的，所以不能为它们创建新的属性。
6. 在实验的时候，发现这些对象都是*函数*。

### 原始值和可变对象的引用

1. 记住，原始值是只读的，且没有属性可言（有属性都是白包装过的）

### 类型转换

1. 原始值和对象之间。原始值和原始值之间可以进行类型转换。
2. 注意，任何时候undefined和null都会由以外发生。undefined转换为数字时为NaN，null转换为数字时为0
3. 任意数组转换为数字都为0
4. `==`比较中会进行类型转换。但这不意味着可以进行类型转换的值使用`==`一定返回true。
5. 可以进行显示转换，通过构造函数挥着重载运算符实现。
6. 字符串和数字之间的直接转换，可以利用`parseInt()`，`parseFloat()`，`toPrecision()`，`toFixed()`，`toExponential()`实现。
7. 善于利用`toString()`和`valueOf()`方法，这两个方法是类型转换中经常使用的函数。
8. 对象到字符串，经历的优先级`toString()`到`valueOf()`到抛出异常。
9. 对象到数字，经历的优先级`valueOf()`到`toString()`，然后由JavaScript转换为数字，或者失败抛出异常。

### 变量声明

1. 使用var声明变量。
2. 允许重复声明。
3. 被遗漏的声明，在非严格模式下会称为全局变量的一个属性。
4. 养成好习惯，使用var来声明变量。
5. 注意，声明语句总是被JavaScript提到其作用域的顶部。

### 变量作用域

1. 局部作用域和全局作用域的关系和Java很类似。
2. JavaScript没有块级作用域的说法，取而代之的是函数作用域，只要是在函数中声明的变量，不管是在哪个大括号内，都是有效的。
3. 注意上面的第五条。变量的作用域和变量的声明位置无关。

### 作为属性的变量

1. 不带var声明一个全局变量，实际上是为全局变量this定义了一个属性。
2. 带var声明一个全局变量，才是一个真的全局变量。
3. 全局变量不能被删除，而全局变量的属性可以被删除。

### 作用域链

1. 作用域链用来查找一个声明的全局变量到底属于谁的属性。

## 表达式和运算符

### 原始表达式

1. 原始表达式是最简单的表达式。原始表达式由单个直接量构成，不含任何计算。

### 对象和数组的初始化表达式

1. 对象使用`{}`表达式初始化。
2. 数组使用`[]`表达式初始化。

### 函数初始化表达式

1. 将函数的名字直接赋值给一个变量。也就是函数语句。

### 属性访问表达式

1. `expression.identifier`
2. `expression[expression]`

### 调用表达式

1. 方法调用使用`.`即可实现。

### 对象创建表达式

1. 使用`new`加构造函数显示对象的创建。当然如果没有任何传入参数，`()`可以省略。

### 运算符概述

1. JavaScript的运算符和Java十分类似。
2. 操作数类型和结果类型可能会被JavaScript转换。
3. 运算会引起副作用，可能会对其他的表达式产生影响。
4. 一元运算符，三元运算符和赋值运算符都有从右到左的结合性。

### 加法运算 比较运算

1. 对象和原始类型的加法运算和比较运算，会转换为原始类型再进行计算。

### 表达式计算

1. 所谓的表达式计算，就是 JavaScript动态解释一个表达式字符串，并输出这个表达式的结果。相当于JavaScript动态添加代码。
2. 表达式计算通过`eval()`来实现。
3. `eval()`接受一个字符串并返回结果，如果参数不是字符串，则直接返回该参数。
4. `eval`是保留字，所以不要在把它赋给其它变量。
5. `eval()`拥有改变全局变量的能力。如果`eval`被赋值给了一个全局变量，那么它接收的值将优先是全局变量，否则优先是局部变量。

## 语句

### 语句语句

1. 和Java差不多，不想细看了。
2. for in 语句是新增的。

### with语句

1. with语句用来拓展作用域链，将某个对象插到链的顶端。
2. 在严格模式下不允许使用with。在非严格模式下要尽量避免使用with。

### debugger语句

1. 这个语句什么都不做，只不过在调试模式中产生一个断电。

### "use strict"

1. 从声明此句开始，下面的脚本都必须使用严格模式执行。

### delete

1. 删除一个属性或对象？它的具体用法还需要了解。

## 对象

1. 可以把对象看做是可能包含自由方法的哈希表。
2. “原型式继承”是JavaScript的核心特征。
3. 除了字符串，数字，布尔值，null和undefined，JavaScript的其它值都是对象。
4. 对象是可变的。
5. 对象的常见方法有：创建，设置，查找，删除，检测和枚举。
6. 对象的属性键可以是任意字符串，包括空字符串。
7. 对象的属性键不能重名。
8. 每个属性还有一些相关联的属性，称为属性特征，它们是：是否可写，是否可枚举，是否可配置（删除修改等的配置）。
9. 每个对象除了拥有属性和方法外，还用三个相关的对象特征，它们是：对象的原型，对象的类，对象的拓展标记（是否可添加属性等）。
10. 内置对象，由ECMAScript规范定义的对象或类，比如数组，函数，日期，正则表达式等。
11. 宿主对象，由JavaScript解释器多嵌入的宿主环境定义的，比如HTMLElement对象等。
12. 自定义对象，由运行中的JavaScript代码产生的对象。
13. 自有属性，直接在对象中定义的属性。
14. 继承属性，在原型对象中定义的属性。

### 创建对象

1. 创建对象的方法有三种，分别是对象直接量，关键字new和`Object.create()`。
2. 对象直接量创建对象，直接使用`{}`和隐射表创建对象。这是最简单的方法。
3. 对象直接量的键，如果包含空格，连词符或关键字，则必须使用引号括起来。一般来说键是不需要用引号的。
4. 关键字new创建对象，new必须跟一个叫做构造函数的函数使用，这个和Java类似。
5. 了解一下什么是原型。原型链类似Java的继承关系。通过`prototype`来表现。这个在后面会有详细的解释。
6. 使用`Object.create()`来创建对象：

```javascript
var x = Object.create({x:1,y:2}) //继承了属性x和y
var y = Object.create(null) //不继承任何属性和方法
var z = Object.create(Object.prototype) //创建了一个普通对象
var o = new Object() //同上
```

### 属性查询和设置

1. 使用`.`和`[]`来访问属性，当属性关键字必须带引号时，必须使用`[]`来引用。
2. 给一个属性赋值，无非两种情况，一种情况是该属性不存在时，一种是该属性存在时。
3. 如果该属性不存在，则新建该属性。
4. 如果该属性存在且不是继承来的，则直接赋值。
5. 如果该属性存在且是继承来的，则该属性会覆盖继承来的属性。如果删除该属性，就能看到继承来的属性了。
6. 如果该属性存在且是继承来的，并且该属性的具有setter方法的accessor方法，此时会调用setter方法而非创建属性。


### 属性访问错误

1. 使用`&&`避免对undefined进行属性访问而得到的错误。
2. 属性只读的话，不可以重新赋值（defineProperty()有一个例外，可以对可配置的只读属性重新赋值）。
3. 属性是继承的，且是只读的，则无法通过同名自有属性覆盖只读的继承属性。
4. 不存在自有属性，且无setter方法供调用，则属性一定会添加到对象中，如果对象不可拓展，则无法添加新属性。

### 删除属性

1. 删除属性只是删除属性和宿主的联系，属性本身没有被删除。
2. delete只能删除自有属性，不能删除继承属性。
3. delete成功返回true，失败返回false。
4. delete不能删除配置性为false的属性。
5. delete什么都没做时，也返回true，包括删除不存在的属性，尝试删除继承来的属性等。

### 检测属性

1. 检测属性有四种方法。
2. 第一种方法，使用`in`，检测到自有属性和继承属性会返回true。
3. 第二种方法，使用`hasOwnProperty`。只能检测自有属性。
4. 第三种方法，使用`propertyIsEnumerable`。只能检测自有属性。
5. 第四种方法，使用`!==undefined`来检测。

### 枚举属性

1. 使用上面的方法来检测属性是否可被枚举，然后使用for方法枚举即可。

### 属性setter和getter

1. 拥有get或set方法的属性称为存取器属性，它和数据属性是不同的。
2. 只有get的存取器属性只读，只有set的存取器属性只写。
3. get和set定义为一个函数体，但它不是函数。

```javascript
var x {
  name:"JS"
  get r(){
    return this.name+" ha ha ha"
  }

  set r(value){
    this.name = "C++"
  }

}
```

### 属性的特性

1. 数据属性有四个特征：值，可写性，可枚举性，可配置性。
2. 存取器属性有四个特征：读取，写入，可枚举性，可配置性。
3. 属性的特性可以通过`Object.getOwnPropertyDescriptor(obj, "attr")`来访问。不能访问继承属性。
4. 修改属性的特性可以使用`Object.defineProperty(obj, "attr", {writable:false})`或`Object.defineProperties()`来实现。

注意：

1. 如果对象不可扩展，则可编辑已有的自有属性，但不能添加新属性。
2. 如果属性是不可配置的，则不能修改它的可配置性和可枚举性。
3. 如果存取器属性是不可配置的，则不能修改getter和setter方法，也不能将它转换为数据属性。
4. 如果数据属性是不可配置的，则不能将它转换为存取器属性。
5. 如果数据属性是不可配置的，则不能将可写性从false变为true。

### 对象的三个属性

1. 这三个属性分别是原型属性，类，可扩展性。
2. 对象的原型属性是用来继承属性的。
3. 类属性是一个字符串，用来表示对象的类型信息。
4. 可扩展性，使用`Object.jsExtensible()`查询，使用`Object.preventExtensions()`修改。可扩展性对原型无效。
5. `Object.seal()`可封闭对象，除了可扩展性的配置，还将所有属性设为不可配置。
6. `Object。freeze()`可冻结对象，除了可扩展性的配置，所有属性设为不可配置以外，还使所有属性为只读（存取器属性意外）。

### 序列化对象

1. 使用JSON序列化对象。

### 对象方法

1. `toString()`
2. `toLocalString()`返回本地化的字符串。
3. `valueOf()`
4. `toJSON()`

## 数组

1. 数组是无类型的，不同类型数据可以放在同一数组里。
2. 数组是动态的，可以根据需要增长或缩减。
3. 数组最大容量$$2^32-1$$。
4. 数组的索引可能不连续，索引不连续的数组称为稀疏数组。

### 创建数组

1. 数组元素可以是直接量也可以是间接量。
2. 数组可以包含undefined。
3. 创建数组使用`[]`或者`new Array()`。

### 数组元素读和写

1. 和Java类似的部分，就不说了。
2. 负数和非整数也能作为索引。不过代表的是数组的属性值。表示非负整数的字符串和浮点数也会当做非负整数处理。

### 稀疏数组

1. 注意undefined和系数数组中索引不存在的细微区别。前者说明数组索引是存在的，只不过是undefined，而后者表示索引直接不存在。
2. 注意in在数组中的用法，in表示的数组的索引而非数组内的元素。

### 数组长度

1. 数组长度通常返回最大索引值加1。
2. 数组长度是可被赋值的，如果赋值比当前真实长度小，则删除多余的元素，如果比当前真实长度大，则追加空白区域。
3. 可以配置数组的长度为只读。
4. 长度只读的数组，不可再增加长度。

### 数组元素的增加和删除

1. 增加尾部`push()`，增加首部`unshift()`。
2. 删除尾部`pop()`，删除首部`shift()`。
3. 删除元素索引`delete a[2]`。此处不在有元素。但不影响length的值。
4. `splice()`用来插入删除或替换数组元素。

### 数组遍历

1. 遍历时考虑剔除undefined和未定义的索引的方法。

### 多维数组

1. 多维数组的使用方法和Java类似。

### 数组方法

1. `join()`，将一个数组连接成字符串，指定连接符。

```javascript
var a = [1,2,3];
a.join("a"); //返回string，对于对象，会转换为字符串
```

2. `reverse()`，逆序数组，返回一个数组。
3. `sort()`，排序数组，返回一个数组。undefined元素会被排在尾部。按照字母表排序。可以为其指定比较函数来自定义比较。
4. `concat()`，返回一个拼接数组，会扁平化处理参数数组，不会改变原数组。

```javascript
var a = [1,2,3,4]
a.concat(1,2,[3,4],[[5,6]]) //返回[1,2,3,4,[5,6]]
```

5. `slice()`，返回一个数组片段，有两个参数时，规定了片段首尾但不包含尾部索引，当一个参数时，规定了片段的首部，当参数为负数时，表示倒数。
6. `splice()`，返回被删除的数组片段，同事改变原数组。它的第一个参数规定了删除或删除元素的起始位置，第二个参数规定了删除元素的个数。第三个参数之后是要插入的元素。如果有插入元素，那么就不会删除原数组的元素了。
7. `push()`和`pop()`，将数组当做栈进行操作。
8. `unshift()`和`shift()`，对数组的首部进行增删工作。
9. `toString()`和`toLocalString()`，转换为字符串的方法。

### ECMAScript 5中数组的方法

1. `forEach()`，传入一个函数，对每个元素进行处理。会修改原数组。
2. `map()`，传入一个带返回值的函数，对每个元素进行处理，不会修改原数组，返回新数组。
3. `filter()`，传入一个函数，用来过滤数组。
4. `every()`和`some()`，传入一个判断函数，对数组内的元素进行判定，返回true或false。
5. `reduce()`和`reduceRight()`，使用指定的函数将数组元素进行组合，生成单个值。
6. `indexOf()`和`lastIndexOf()`，正向和反向搜索元素所在位置。

### 数组类型

1. 判断是否是数组，使用`Array.isArray()`方法。

### 作为数组的字符串

1. 字符串可以作为数组使用，进行索引。

## 函数

1. 函数即变量。

### 函数定义

1. 函数定义由function，函数名称标识符，一对圆括号和形参列表，以及一个花括号构成。以表达式方式定义函数，函数名称标识符并非必要。
2. 函数可以嵌套。我们主要考察作用域问题。

### 函数调用

1. 调用函数有四种方法：作为函数，作为方法，作为构造函数，通过它们的`call()`或`apply()`间接调用。
2. 使用调用表达式来进行作为函数的调用。作为函数调用的this的值是全局对象，而严格模式下上下文是undefined。这样可以判断当前是否在严格模式下。
3. 做为方法调用，将函数名称标识符赋值给对象的一个属性。可以生成方法链调用。
4. 作为构造函数调用，没有形参的情况下可以省略小括号。
5. 间接调用，接下来会讨论。

### 函数的形参和实参

1. 在实际使用中传入的实参个数可以比形参个数少，没有传入的形参都是undefined。使用`a=a||[]`可以返回参数a的值或a的默认值。
2. 实参列表由一个类数组对象`arguments`维护。可以处理实参比形参多的情况。通过它还能接受无限多的实参。
3. 函数可以接收一个对象参数，这样可以使用对象的属性为参数。
4. 函数的形参从不指定数据类型。

### 作为值的函数

1. 函数作为值传递给一个变量。

### 作为命名空间的函数

1. 
