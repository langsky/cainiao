# JavaScript 语言核心

## 词法结构
词法结构定义了编程语言的编写方式。

### 字符集

* JavaScript使用Unicode字符集书写。3版本要求Unicode2.1以上，5版本要求Unicode3以上。
* JavaScript区分大小写，但是和HTML交互时，传入变量一律使用小写。这是因为客户端JS和HTML关系紧密，而HTML不区分大小写。

```javascript
ai["boom"] //一律用小写
ai["Boom"] //不要这样写
```

* JavaScript中可以随意使用换行和空格，可以通过换行和空格增强程序可读性。部分格式控制符理解为一个空格，部分格式控制符理解为行结束符。书写方向标识符不要用在标识符上。
* JavaScript支持Unicode的转义序列。且它们是`===`关系。注意，在注释中使用转义符并不会被翻译为字符，而是保留了它的ASCII码形式。
* 虽然在某些显示系统中会将不同的字符显示为一样的形式，但是请注意，这些看起来一样的字符本质上是不相同的。尽量使用标准化的字符表示法。

### 注释

1. JavaScript和Java的注释类似。使用`//`和`/* */`。

### 直接量

* 直接量，就是在程序中直接使用的值。比如数字，字符串等。
* 本质上不是由变量符号引出的量都是直接量。

### 标识符

* 标识符以`$ _ `和字母开头。
* 字母不仅仅指英文字母，还可以是数学符号（一般是常量符号），其他语言字母，甚至是中文。
* 为了便于移植程序，请尽量使用ASCII码定义标识符。
* 保留字不能用作标识符。

### 保留字

* 保留字不允许作为标识符。
* JavaScript定义了许多全局变量，不要使用全局变量作为标识符。
* E3版本中有许多保留字，而在E5中增加了表示类型关系的新7个保留字。
* 此外还有9个保留字只在严格模式下起作用。
* 严格模式下`arguments`和`eval`虽然不是保留字，但也不能作为标识符。
* E3版本集成了Java的保留字，虽然某些保留字在E5中有所放松，但你仍要尽量避免使用它们作为标识符。
* 此外JavaScript还定义了若干的全局变量和函数，它们虽然不是保留字，但你也需要避免使用它们作为标识符。

### 分号

* 分号不是必须的。
* 分号只有在解析出现语义歧义时才派上用场。
* JavaScript自行添加的断句往往和期望结果不一致，所以不要偷懒，还是使用分号吧。

## 类型 值 变量

* JavaScript的数据类型分为两类，分别是原始类型和对象类型。
* 原始类型包括数字，字符串，布尔值。
* 原始类型中还有一种null和undefind的特殊类型，它们是特立独行的。
* 除了原始类型，就是对象类型。对象类型可以看作是键值对的集合。
* 对象类型中有一种特殊的形式，称为全局对象。
* 普通对象类型是键值的无序集合，JavaScript还提供了一种有序集合对象，称为数组。
* 函数是一种特殊的对象类型。特殊之处在于，它的行为特征和普通对象完全不一样。
* JavaScript支持类型转换，并且大部分时候类型转换隐式发生。
* JavaScript采用词法作用域来限定变量的作用范围。

### 数字

* JavaScript不区分整数值和浮点值。所有数字均采用浮点数值表示。
* JavaScript整数值范围[$-2^53$,$2^53$]
* JavaScript实际的操作基于32位整数。
* 数字是直接量。不可修改大小。
* 整形数字可以使用八进制(010)，十进制(8)和十六进制表示(0x8)。尽量不要使用八进制，因为你无法确定宿主是否支持八进制解析。
* 浮点数字可以使用科学计数法表示。
* 数字支持加减乘除余计算，同时对象`Math`支持更复杂的计算。
* JavaScript数字会溢出。分为无穷大`Infinity`（上溢）和趋于0（正负0）（下溢）的情况。当然会保留正负号以说明溢出情况。
* JavaScript除数为0不会报错，但是0除以0时结果会返回`NaN`。`Infinity`和`NaN`是**全局变量**。
* `NaN`十分特殊，它和任何值都不相等，包括它自己，所以判断方式是`i!=i`，为真就是`NaN`。
* 正0和负0相等，但它们作为除数时的计算结果不相等。

```javascript
0===-0 //true
1/0===1/-0 //false

Infinity-1000000000000 //Infinity
Infinity-Infinity //NaN
```
* JavaScript无法准确表示十进制的小数。这和计算机的计算结构有关。所以在进行精确计算时，应当避免使用小数计算。
* `Date`类型提供时间的计算方法。

### 文本

* JavaScript字符串以UTF-16编码格式的Unicode码。
* JavaScript定义的字符串操作方法均作用于16位值。（这个要研究一下，还没搞清楚哪些字符可能输出2的长度）
* 字符串自带计算方法，用来返回处理后的结果。注意，字符串本身不会改变。
* JavaScript支持使用正则表达式匹配字符串。
* E3版本中，字符串直接量必须写在一行中，而在E5版本只需要`\`就能多行书写。

```javascript
"hello \
world \
hehe "
```

* `\`还有转义字符的作用。

### 布尔值

* 布尔值只有两个，true和false。
* undefined，null，0，-0，NaN，""都是false。

### null undefined

* null的本质是一个对象，含义是“非对象”。它用来表示任何类型的特殊型。
* undefined表示对象不存在，即未初始化或未声明。
* 如果函数没有返回值，就返回undefined。
* 它们没有成员方法，不要尝试去取它们的属性。
* null==undefined, null!==undefined

```javascript
> typeof(null)
'object'
> typeof(undefined)
'undefined'
> typeof(NaN)
'number'
> typeof(Infinity)
'number'
```

### 全局对象

* 全局对象在解释器启动时创建。
* 全局对象包含全局属性，全局函数，构造函数，全局对象。
* 全局属性，比如`NaN`，`undefined`，`Infinity`等。
* 全局函数，比如`isNaN()`，`parseInt()`等。
* 构造函数，比如`Date()`，`RegExp()`等。
* 全局对象，比如Math，JSON等。
* 全局属性并不是保留字，但是它们应当被看作是保留字。
* 全局属性一部分来自JavaScript本身，一部分来自客户端JavaScript。
* 获取全局变量的一个引用，在文件头部声明一个变量`var global = this`即可。

### 包装对象

* 很奇怪原始类型比如数字，布尔，字符串为什么会有属性呢？
* 这是因为在你试图访问属性时，JavaScript为这些原始类型临时创建了一个对象。
* 这个过程叫做包装对象。
* 包装产生的对象不会长时间存在，所以不要给它们指定新的属性，因为那是不成功的。

```javascript
> var s ="yes";s.len=4;s.len
undefined //原因是第二语句执行后s包装被销毁，属性失效
```

* 或者说，原始对象都是只读的，所以不能为它们创建新的属性。
* 使用构造函数可以显式包装对象。

### 原始值和可变对象的引用

* 记住，原始值是只读的，且没有属性可言（有属性都是白包装过的）

### 类型转换

* 原始值和对象之间,原始值和原始值之间可以进行类型转换。
* 注意，任何时候undefined和null都会有意外发生。undefined转换为数字时为NaN，null转换为数字时为0，下面的表格表示转换关系。

|值|字符串|数字|布尔|对象|
|---|---|---|---|---|
|undefined|"undefined"|NaN|false|throws TypeError|
|null|"null"|0|false|throws TypeError|
|true|"true"|1||Boolean(true)|
|false|"false"|0||Boolean(false)|
|""||0|false|String("")|
|"1.2"||1.2|true|String("1.2")|
|"one"||NaN|true|String("one")|
|0|"0"||false|number(0)|
|-0|"0"||false|number(-0)|
|NaN|"NaN"||false|number(NaN)|
|Infinity|"Infinity"||true|number(Infinity)|
|-Infinity|"-Infinity"||true|number(-Infinity)|
|任意对象|特别参考|特别参考|true||
|任意数组|""|0|true||
|[3]一个数字元素|"9"|9|true||
|['a']其它数组|join()|NaN|true||
|任意函数|特别参考|NaN|true||

* 任意数组转换为数字都为0
* `==`比较中会进行类型转换。但这不意味着可以进行类型转换的值使用`==`一定返回true。

```javascript
> var a = 1111;if(undefined){a=2222} a
1111 //a值不变，说明undefined转化为了false
> undefined == false
false //但是它们并不相等
```
* 可以进行显示转换，通过构造函数挥着重载运算符实现。

```javascript
> +"123"
123
> 123+""
'123'
> !!123
true
> !123
false
> +false
0
> +true
1
```

* 字符串和数字之间的直接转换，可以利用number类的`parseInt()`，`parseFloat()`，`toPrecision()`，`toFixed()`，`toExponential()`实现。具体使用方法在实践中说明。
* 善于利用`toString()`和`valueOf()`方法，这两个方法是类型转换中经常使用的函数。

#### 对象和原始值的相互转换

* 所有对象继承了两个方法，分别是`toString()`和`valueOf()`，来执行相互转换。
* `toString()`方法，将对象转换为默认字符串。
* `valueOf()`方法，返回对象默认对应的原始值，如果默认原始值不存在，就返回对象本身。
* 对象到字符串，经历的优先级`toString()`到`valueOf()`到抛出异常。
* 对象到数字，经历的优先级`valueOf()`到`toString()`，然后由JavaScript转换为数字，或者失败抛出异常。
* `+`,`==`,`!=`和关系运算符是唯一执行特殊的字符串到原始方式的运算符。

### 变量声明

* 使用var声明变量。
* 允许重复声明。比如：

```javascript
> var a = 100; a = "hello"; a
'hello'
```

* 被遗漏的声明，在非严格模式下会成为全局变量的一个属性。
* 养成好习惯，使用var来声明变量。
* 注意，声明语句总是被JavaScript提到其作用域的顶部。

### 变量作用域

* 局部作用域和全局作用域的关系和Java很类似。函数内部的变量只在函数内部起作用，并且比全局变量的优先级高。
* 务必为变量加上`var`，否则它将成为全局对象的一个属性，而不管它在函数内还是函数外。
* JavaScript没有块级作用域的说法，取而代之的是函数作用域，只要是在函数中声明的变量，不管是在哪个大括号内，都是有效的。

```javascript
> function b(){var i; for(i=1;i<5;i++){var j = i+1;} return j;};b()
5
```
* 注意上面的第五条。变量的作用域和变量的声明位置无关。

### 作为属性的变量

* 不带var声明一个全局变量，实际上是为全局对象this定义了一个属性。
* 带var声明一个全局变量，才是一个真的全局变量。它不是全局对象的属性。
* 全局变量不能被删除，而全局变量的属性可以被删除。
* 注意，如果一个变量作为全局变量的属性后，由声明了同名的全局变量，则该属性值将被全局变量值覆盖。

```javascript
> aa = 1111
1111
> this.aa
1111
> var aa = 2222
undefined
> aa
2222
> this.aa
2222
```

### 作用域链

* 作用域链用来查找一个声明的全局变量到底属于谁的属性。
* 作用域链基于一种假设，任何变量都是某个对象的属性。而不同的作用域存在不同数量的对象，在查找一个属性时，总会沿着这个对象链查找。找到就返回结果，找不到就抛出异常。
* 我们在全局内存在一个全局对象，在函数内存在函数关联的对象和全局对象，在嵌套的函数内，至少存在三个对象。
* 这些对象存不存在我也不知道。

## 表达式和运算符

* 表达式就是一个短语。简单的表达式通过运算符连接成复杂的表达式。

### 原始表达式

* 原始表达式是最简单的表达式。原始表达式由单个直接量构成，不含任何计算。

### 对象和数组的初始化表达式

* 对象和数组的初始化表达式实质上是创建一个新的对象和数组。
* 对象使用`{}`表达式初始化。
* 数组使用`[]`表达式初始化。

### 函数定义表达式

1. 将函数的名字直接赋值给一个变量。构成函数定义表达式。

```javascript
> var a = function(){}
undefined
> a
[Function: a]
```

* 除了使用函数定义表达式，函数的定义还可以使用函数语句。

### 属性访问表达式

* `expression.identifier`
* `expression[expression]`，这种情况下，括号内的表达式最终会被计算为字符串使用。

### 调用表达式

* 调用表达式针对函数或方法的调用。
* 方法调用使用`.`即可实现。

### 对象创建表达式

* 使用`new`加构造函数显示对象的创建。当然如果没有任何传入参数，`()`可以省略。

### 运算符概述

* 运算符用来连接表达式。
* 运算符不仅包含运算符号，还包含`delete`等单词型运算符。
* JavaScript的运算符和Java十分类似。
* 操作数类型和结果类型可能会被JavaScript转换。

```javascript
> "3"*"5"
15
```
* 运算会引起副作用，可能会对其他的表达式产生影响。比如`delete`删除一个属性，本质上是给这个属性赋值为`undefined`。
* 一元运算符，三元运算符和赋值运算符都有从右到左的结合性。

### 加法运算 比较运算

* 对象和原始类型的加法运算和比较运算，会转换为原始类型再进行计算。
* 任何比较都是基于原始值比较的。
* 任何加法计算都是基于原始值计算的。如果操作式中有字符串，则结果输出字符串，否则输出数字。
* 本质上说，在对象加减法中，对象将调用`valueOf()`将自己变为数字，但是大部分对象不具备此方法，只能退而求此次转换为字符串了。

### 关系表达式
关注`===`和`==`的不同之处。

#### `===`

* `===`的比较不允许类型转换。
* 如果两个值类型不同，则不相等。
* 如果两个值都为null或undefined，则不相等。
* 如果两个值至少有一个NaN，则不相等。
* 如果两个值一个为0一个为-0，则相等。
* 如果两个字符串的16位编码值不相等，则不相等。
* 如果两个值指向同一个对象，则相等。

#### `==`

* `==`用来比较值是否相等。
* null和undefined是相等的。
* 数字和字符串的比较，先将字符串转换为数字，再比较。
* true转换成1，false转换为0进行比较。
* 对象和数字与字符串的比较，对象进行转换后再进行比较。
* 其它不同类型的比较均不相等。

#### 其它比较

* 字符串比较大小，比较首字母的unicode编码。
* Infinity总是最大的，-Infinity总是最小的，NaN和任何值都不想等。

### 逻辑表达式

逻辑表达式主要关注`&&`，`||`和`!`。

#### `&&`

* `&&`有短路作用，即在第一个操作数为false时不再计算第二个操作数，这样一来可以避免由`null`或`undefined`取属性操作导致的错误。

```javascript
> var undef
undefined
> undef && undef.len
undefined
> undef.len
TypeError: Cannot read property 'len' of undefined
```

* 注意`&&`返回的并非true或false，而是一个确切的值。

#### `||`

* `||`同样具备短路功能，遇到第一个true时直接返回。

```javascript
> aa
2222
> var bb
undefined
> var cc = bb || aa //如果bb为true，就返回bb，否则返回aa
undefined
> cc
2222
```

### 表达式计算

* 所谓的表达式计算，就是 JavaScript动态解释一个表达式字符串，并输出这个表达式的结果。相当于JavaScript动态添加代码。
* 表达式计算通过`eval()`来实现。

#### `eval()`是函数还是运算符

`eval()`是一个函数，但是它作为函数存在的时候，解释器无法对包含它和它的饮用的所有函数进行优化。这是一个大问题。

#### `eval()`的返回值

`eval()`接受一个字符串并返回结果，如果参数不是字符串，则直接返回该参数。字符串应当是一个表达式，或一个函数，`eval()`将返回最后一个表达式的结果或返回值。否则返回`undefined`。

#### 全局`eval()`

* 在E3标准中，给`eval`指定全局名称使用，会直接抛出`EvalError`错误。
* 在E5标准中，取消了`EvalError`错误，在全局使用(别名使用)时，`Eval`操作被看做是全局的操作，而不管它是不是在函数内。局部使用中，`Eval`才会对局部起作用。

```javascript
> var global = eval; var value = "global";function a(){var value ="local";return eval("value")} function b(){var value = "local"; return global("value")}
undefined
> a()
'local'
> b()
'global'
```
* 严格模式下的`eval()`不允许使用别名，只能访问局部变量，不能创建新的局部变量。

### delete和void

* delete运算符是对属性进行undefined赋值处理。记住这一点。
* void运算符是为了忽略返回值信息。

## 语句

### 语句语句

1. 和Java差不多，不想细看了。
2. for in 语句是新增的。

### with语句

1. with语句用来拓展作用域链，将某个对象插到链的顶端。
2. 在严格模式下不允许使用with。在非严格模式下要尽量避免使用with。

### debugger语句

1. 这个语句什么都不做，只不过在调试模式中产生一个断点。

### "use strict"

* 从声明此句开始，下面的脚本都必须使用严格模式执行。
* 严格模式中，所有变量都必须先声明，再使用。

```javascript
a = 11 //不允许
var a = 11 //正确
```

* 严格模式中，函数内部的this引用是undefined。非严格模式是全局变量。
* 严格模式下，调用`call()`和`apply()`的第一个参数，就是函数的this。
* 严格模式下，给只读或不可扩展对象创建新的成员会抛出异常，非严格模式下只会操作失败，不会抛出异常。
* 严格模式下，`eval`不能声明新的变量和函数。
* 严格模式下，`delete`后跟非法字符会抛出异常。
* 严格模式下，试图删除一个不可配置的属性将抛出类型错误异常。
* 严格模式下，对象直接量中定义多个同名错误将抛出错误，非严格模式不会抛出错误。
* 严格模式下，函数声明存在多个同名参数将抛出一个语法错误。
* 严格模式下，不允许使用八进制直接量。
* 严格模式下，eval和argument是关键字，不能更改。
* 严格模式下，限制了栈的检测能力。

### delete

1. 不能删除var定义的对象。

## 对象

1. 可以把对象看做是可能包含自由方法的哈希表。
2. “原型式继承”是JavaScript的核心特征。
3. 除了字符串，数字，布尔值，null和undefined，JavaScript的其它值都是对象。
4. 对象是可变的。
5. 对象的常见方法有：创建，设置，查找，删除，检测和枚举。
6. 对象的属性键可以是任意字符串，包括空字符串。
7. 对象的属性键不能重名。
8. 每个属性还有一些相关联的属性，称为属性特征，它们是：是否可写，是否可枚举，是否可配置（删除修改等的配置）。
9. 每个对象除了拥有属性和方法外，还用三个相关的对象特征，它们是：对象的原型，对象的类，对象的拓展标记（是否可添加属性等）。
10. 内置对象，由ECMAScript规范定义的对象或类，比如数组，函数，日期，正则表达式等。
11. 宿主对象，由JavaScript解释器多嵌入的宿主环境定义的，比如HTMLElement对象等。
12. 自定义对象，由运行中的JavaScript代码产生的对象。
13. 自有属性，直接在对象中定义的属性。
14. 继承属性，在原型对象中定义的属性。

### 创建对象

1. 创建对象的方法有三种，分别是对象直接量，关键字new和`Object.create()`。
2. 对象直接量创建对象，直接使用`{}`和隐射表创建对象。这是最简单的方法。
3. 对象直接量的键，如果包含空格，连词符或关键字，则必须使用引号括起来。一般来说键是不需要用引号的。
4. 关键字new创建对象，new必须跟一个叫做构造函数的函数使用，这个和Java类似。
5. 了解一下什么是原型。原型链类似Java的继承关系。通过`prototype`来表现。这个在后面会有详细的解释。
6. 使用`Object.create()`来创建对象：

```javascript
var x = Object.create({x:1,y:2}) //继承了属性x和y
var y = Object.create(null) //不继承任何属性和方法
var z = Object.create(Object.prototype) //创建了一个普通对象
var o = new Object() //同上
```

### 属性查询和设置

1. 使用`.`和`[]`来访问属性，当属性关键字必须带引号时，必须使用`[]`来引用。
2. 给一个属性赋值，无非两种情况，一种情况是该属性不存在时，一种是该属性存在时。
3. 如果该属性不存在，则新建该属性。
4. 如果该属性存在且不是继承来的，则直接赋值。
5. 如果该属性存在且是继承来的，则该属性会覆盖继承来的属性。如果删除该属性，就能看到继承来的属性了。
6. 如果该属性存在且是继承来的，并且该属性的具有setter方法的accessor方法，此时会调用setter方法而非创建属性。


### 属性访问错误

1. 使用`&&`避免对undefined进行属性访问而得到的错误。
2. 属性只读的话，不可以重新赋值（defineProperty()有一个例外，可以对可配置的只读属性重新赋值）。
3. 属性是继承的，且是只读的，则无法通过同名自有属性覆盖只读的继承属性。
4. 不存在自有属性，且无setter方法供调用，则属性一定会添加到对象中，如果对象不可拓展，则无法添加新属性。

### 删除属性

1. 删除属性只是删除属性和宿主的联系，属性本身没有被删除。
2. delete只能删除自有属性，不能删除继承属性。
3. delete成功返回true，失败返回false。
4. delete不能删除配置性为false的属性。
5. delete什么都没做时，也返回true，包括删除不存在的属性，尝试删除继承来的属性等。

### 检测属性

1. 检测属性有四种方法。
2. 第一种方法，使用`in`，检测到自有属性和继承属性会返回true。
3. 第二种方法，使用`hasOwnProperty`。只能检测自有属性。
4. 第三种方法，使用`propertyIsEnumerable`。只能检测自有属性。
5. 第四种方法，使用`!==undefined`来检测。

### 枚举属性

1. 使用上面的方法来检测属性是否可被枚举，然后使用for方法枚举即可。

### 属性setter和getter

1. 拥有get或set方法的属性称为存取器属性，它和数据属性是不同的。
2. 只有get的存取器属性只读，只有set的存取器属性只写。
3. get和set定义为一个函数体，但它不是函数。

```javascript
var x {
  name:"JS"
  get r(){
    return this.name+" ha ha ha"
  }

  set r(value){
    this.name = "C++"
  }

}
```

### 属性的特性

1. 数据属性有四个特征：值，可写性，可枚举性，可配置性。
2. 存取器属性有四个特征：读取，写入，可枚举性，可配置性。
3. 属性的特性可以通过`Object.getOwnPropertyDescriptor(obj, "attr")`来访问。不能访问继承属性。
4. 修改属性的特性可以使用`Object.defineProperty(obj, "attr", {writable:false})`或`Object.defineProperties()`来实现。

注意：

1. 如果对象不可扩展，则可编辑已有的自有属性，但不能添加新属性。
2. 如果属性是不可配置的，则不能修改它的可配置性和可枚举性。
3. 如果存取器属性是不可配置的，则不能修改getter和setter方法，也不能将它转换为数据属性。
4. 如果数据属性是不可配置的，则不能将它转换为存取器属性。
5. 如果数据属性是不可配置的，则不能将可写性从false变为true。

### 对象的三个属性

1. 这三个属性分别是原型属性，类，可扩展性。
2. 对象的原型属性是用来继承属性的。
3. 类属性是一个字符串，用来表示对象的类型信息。
4. 可扩展性，使用`Object.jsExtensible()`查询，使用`Object.preventExtensions()`修改。可扩展性对原型无效。
5. `Object.seal()`可封闭对象，除了可扩展性的配置，还将所有属性设为不可配置。
6. `Object。freeze()`可冻结对象，除了可扩展性的配置，所有属性设为不可配置以外，还使所有属性为只读（存取器属性意外）。

### 序列化对象

1. 使用JSON序列化对象。

### 对象方法

1. `toString()`
2. `toLocalString()`返回本地化的字符串。
3. `valueOf()`
4. `toJSON()`

## 数组

1. 数组是无类型的，不同类型数据可以放在同一数组里。
2. 数组是动态的，可以根据需要增长或缩减。
3. 数组最大容量$$2^32-1$$。
4. 数组的索引可能不连续，索引不连续的数组称为稀疏数组。

### 创建数组

1. 数组元素可以是直接量也可以是间接量。
2. 数组可以包含undefined。
3. 创建数组使用`[]`或者`new Array()`。

### 数组元素读和写

1. 和Java类似的部分，就不说了。
2. 负数和非整数也能作为索引。不过代表的是数组的属性值。表示非负整数的字符串和浮点数也会当做非负整数处理。

### 稀疏数组

1. 注意undefined和系数数组中索引不存在的细微区别。前者说明数组索引是存在的，只不过是undefined，而后者表示索引直接不存在。
2. 注意in在数组中的用法，in表示的数组的索引而非数组内的元素。

### 数组长度

1. 数组长度通常返回最大索引值加1。
2. 数组长度是可被赋值的，如果赋值比当前真实长度小，则删除多余的元素，如果比当前真实长度大，则追加空白区域。
3. 可以配置数组的长度为只读。
4. 长度只读的数组，不可再增加长度。

### 数组元素的增加和删除

1. 增加尾部`push()`，增加首部`unshift()`。
2. 删除尾部`pop()`，删除首部`shift()`。
3. 删除元素索引`delete a[2]`。此处不在有元素。但不影响length的值。
4. `splice()`用来插入删除或替换数组元素。

### 数组遍历

1. 遍历时考虑剔除undefined和未定义的索引的方法。

### 多维数组

1. 多维数组的使用方法和Java类似。

### 数组方法

1. `join()`，将一个数组连接成字符串，指定连接符。

```javascript
var a = [1,2,3];
a.join("a"); //返回string，对于对象，会转换为字符串
```

2. `reverse()`，逆序数组，返回一个数组。
3. `sort()`，排序数组，返回一个数组。undefined元素会被排在尾部。按照字母表排序。可以为其指定比较函数来自定义比较。
4. `concat()`，返回一个拼接数组，会扁平化处理参数数组，不会改变原数组。

```javascript
var a = [1,2,3,4]
a.concat(1,2,[3,4],[[5,6]]) //返回[1,2,3,4,[5,6]]
```

5. `slice()`，返回一个数组片段，有两个参数时，规定了片段首尾但不包含尾部索引，当一个参数时，规定了片段的首部，当参数为负数时，表示倒数。
6. `splice()`，返回被删除的数组片段，同事改变原数组。它的第一个参数规定了删除或删除元素的起始位置，第二个参数规定了删除元素的个数。第三个参数之后是要插入的元素。如果有插入元素，那么就不会删除原数组的元素了。
7. `push()`和`pop()`，将数组当做栈进行操作。
8. `unshift()`和`shift()`，对数组的首部进行增删工作。
9. `toString()`和`toLocalString()`，转换为字符串的方法。

### ECMAScript 5中数组的方法

1. `forEach()`，传入一个函数，对每个元素进行处理。会修改原数组。
2. `map()`，传入一个带返回值的函数，对每个元素进行处理，不会修改原数组，返回新数组。
3. `filter()`，传入一个函数，用来过滤数组。
4. `every()`和`some()`，传入一个判断函数，对数组内的元素进行判定，返回true或false。
5. `reduce()`和`reduceRight()`，使用指定的函数将数组元素进行组合，生成单个值。
6. `indexOf()`和`lastIndexOf()`，正向和反向搜索元素所在位置。

### 数组类型

1. 判断是否是数组，使用`Array.isArray()`方法。

### 作为数组的字符串

1. 字符串可以作为数组使用，进行索引。

## 函数

1. 函数即变量。

### 函数定义

1. 函数定义由function，函数名称标识符，一对圆括号和形参列表，以及一个花括号构成。以表达式方式定义函数，函数名称标识符并非必要。
2. 函数可以嵌套。我们主要考察作用域问题。

### 函数调用

1. 调用函数有四种方法：作为函数，作为方法，作为构造函数，通过它们的`call()`或`apply()`间接调用。
2. 使用调用表达式来进行作为函数的调用。作为函数调用的this的值是全局对象，而严格模式下上下文是undefined。这样可以判断当前是否在严格模式下。
3. 做为方法调用，将函数名称标识符赋值给对象的一个属性。可以生成方法链调用。
4. 作为构造函数调用，没有形参的情况下可以省略小括号。
5. 间接调用，接下来会讨论。

### 函数的形参和实参

1. 在实际使用中传入的实参个数可以比形参个数少，没有传入的形参都是undefined。使用`a=a||[]`可以返回参数a的值或a的默认值。
2. 实参列表由一个类数组对象`arguments`维护。可以处理实参比形参多的情况。通过它还能接受无限多的实参。
3. 函数可以接收一个对象参数，这样可以使用对象的属性为参数。
4. 函数的形参从不指定数据类型。

### 作为值的函数

1. 函数作为值传递给一个变量。

### 作为命名空间的函数

1. 函数内部的变量的作用于被困在函数内部,不会对外部造成污染。

```javascript
(function(){...}());
```

### 闭包

### 函数属性，方法和构造函数

### 函数式编程

## 类和模块

### 类和原型

### 类和构造函数

### JavaScript中Java式的类继承

### 类的扩充

### 类和类型

### JavaScript中面向对象技术

### 子类

### JavaScript5中的类

### 模块

## 正则表达式的模式匹配

### 正则表达式的定义

### 用于模式匹配的String方法

### RegExp对象

## JavaScript的子集和扩展

### JavaScript的子集

### 常量和局部变量

### 解构赋值

### 迭代

### 函数简写

### 多catch从句

### EXMAScript for XML

## 服务器端JavaScript

### 用Rhino脚本化Java

### 用Node实现异步I/O
